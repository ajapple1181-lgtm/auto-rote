<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>打撃ローテ自動生成</title>

  <style>
    :root{
      color-scheme: dark;

      --bg0:#000714;
      --bg1:#020817;

      --border:rgba(148,163,253,.22);
      --borderSoft:rgba(148,163,253,.14);
      --border2:rgba(56,189,248,.32);

      --text:#e5e7eb;
      --muted:#9ca3af;
      --muted2:#6b7280;

      --accent:#38bdf8;
      --accent2:#6366f1;

      --shadow: 0 24px 80px rgba(0,0,0,.55);

      --r-xl: 24px;
      --r-md: 18px;
      --r-sm: 14px;

      --font: ui-sans-serif, system-ui, -apple-system, "SF Pro Text", "Noto Sans JP", sans-serif;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      padding:22px 14px 30px;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 8% 0%, rgba(99,102,241,.18), transparent 60%),
        radial-gradient(900px 600px at 88% 10%, rgba(56,189,248,.16), transparent 62%),
        radial-gradient(1200px 900px at 50% 110%, rgba(14,165,233,.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      -webkit-font-smoothing: antialiased;
      font-size: 13px;
      position: relative;
      overflow-x:hidden;
    }

    /* 背景ロゴ：同階層に gifu.png を置く */
    body::before{
      content:"";
      position: fixed;
      inset: -10% -10%;
      background: url("./gifu.png") center/contain no-repeat;
      opacity: 0.28;           /* 背景が見えない対策で少し濃く */
      pointer-events:none;
      z-index: -1;             /* UIに被せない */
      transform: rotate(-6deg);
      filter: drop-shadow(0 40px 120px rgba(0,0,0,.45));
    }

    .wrap{ max-width: 1220px; margin:0 auto; position:relative; z-index:1; }

    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      margin-bottom:14px;
    }

    .brand h1{
      margin:0;
      font-size: 26px;
      letter-spacing: .08em;
      font-weight: 760;
      line-height: 1.15;
    }

    .brand .sub{
      margin-top:6px;
      color: var(--muted);
      font-size: 10px;
      line-height: 1.75;
      max-width: 920px;
    }

    .badge{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(2,6,23,.45);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      font-size: 10px;
      color: var(--muted);
      white-space: nowrap;
    }

    .dot{
      width:9px; height:9px; border-radius: 999px;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 4px rgba(56,189,248,.10);
    }

    .badge b{ color: var(--text); font-weight: 700; letter-spacing:.04em; }

    .app{
      display:grid;
      grid-template-columns: minmax(0, 1.55fr) minmax(0, 2.05fr);
      gap: 18px;
      padding: 18px;
      border-radius: var(--r-xl);
      border: 1px solid var(--border);
      background:
        linear-gradient(180deg, rgba(2,6,23,.58), rgba(2,6,23,.35)),
        radial-gradient(circle at top left, rgba(56,189,248,.12), transparent 55%),
        radial-gradient(circle at top right, rgba(99,102,241,.10), transparent 55%);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    @media (max-width: 900px){
      .app{ grid-template-columns: 1fr; padding: 14px; }
      .top{ flex-direction: column; align-items:flex-start; }
    }

    .card{
      border-radius: var(--r-md);
      border: 1px solid var(--border);
      background: rgba(2,6,23,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }

    .card-h{
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(148,163,253,.14);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background:
        radial-gradient(circle at 10% 0%, rgba(56,189,248,.10), transparent 55%),
        radial-gradient(circle at 90% 0%, rgba(99,102,241,.08), transparent 55%);
    }

    .card-b{ padding: 10px 12px 12px; }

    .title{
      display:flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      font-weight: 700;
      color: #c7d2fe;
      letter-spacing: .06em;
    }

    .icon{
      width: 18px; height:18px;
      display:grid; place-items:center;
      border-radius: 8px;
      border: 1px solid var(--border2);
      color: var(--accent);
      background: rgba(56,189,248,.06);
      font-size: 10px;
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      margin: 6px 0 10px;
    }

    .btn{
      padding: 10px 13px;
      border-radius: 999px;
      border: none;
      cursor:pointer;
      font-size: 11px;
      font-weight: 750;
      letter-spacing: .04em;
      color: #02101a;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      box-shadow: 0 16px 40px rgba(56,189,248,.20);
      transition: transform .16s ease, box-shadow .16s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }

    .btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 22px 55px rgba(99,102,241,.24);
    }

    .btn-o{
      padding: 10px 13px;
      border-radius: 999px;
      border: 1px solid rgba(56,189,248,.60);
      background: rgba(2,6,23,.28);
      color: var(--accent);
      cursor:pointer;
      font-size: 11px;
      font-weight: 750;
      letter-spacing: .04em;
      transition: background .16s ease, transform .16s ease, box-shadow .16s ease;
      user-select:none;
    }

    .btn-o:hover{
      background: rgba(2,6,23,.55);
      transform: translateY(-1px);
      box-shadow: 0 18px 45px rgba(0,0,0,.28);
    }

    .hint{
      margin-top: 6px;
      color: var(--muted);
      font-size: 10px;
      line-height: 1.7;
    }

    .listHead{
      display:grid;
      grid-template-columns: minmax(0,2.2fr) .7fr .7fr .72fr 24px;
      gap:8px;
      align-items:center;
      padding: 10px 10px 8px;
      border-radius: var(--r-sm);
      border: 1px solid var(--borderSoft);
      background: rgba(2,6,23,.18);
      color: var(--muted);
      font-size: 10px;
      letter-spacing: .06em;
      margin: 10px 0 8px;
    }

    .hcell{ text-align:center; }
    .hcell.left{ text-align:left; padding-left:2px; }

    .listTotal{
      display:grid;
      grid-template-columns: minmax(0,2.2fr) .7fr .7fr .72fr 24px;
      gap:8px;
      align-items:center;
      margin: -6px 0 10px;
      padding: 0 10px 8px;
      color: var(--muted2);
      font-size: 10px;
      letter-spacing: .04em;
    }

    .listTotal .tcell{ text-align:center; }
    .listTotal .tcell.left{ text-align:left; padding-left:2px; }
    .listTotal b{ color: var(--text); font-weight: 750; }

    .row{
      display:grid;
      grid-template-columns: minmax(0,2.2fr) .7fr .7fr .72fr 24px;
      gap:8px;
      align-items:center;
      margin-bottom: 8px;
      padding: 10px;
      border-radius: var(--r-sm);
      border: 1px solid var(--borderSoft);
      background: rgba(2,6,23,.14);
    }

    label{
      display:block;
      font-size: 9px;
      color: var(--muted2);
      margin-bottom: 4px;
      letter-spacing: .05em;
    }

    input[type="text"], input[type="number"]{
      width:100%;
      padding: 9px 10px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,253,.24);
      background: rgba(2,6,23,.65);
      color: var(--text) !important;
      -webkit-text-fill-color: var(--text) !important;
      caret-color: var(--text) !important;
      outline:none;
      font-size: 11px;
      opacity: 1 !important;
    }

    /* iOSのオートフィルで文字色が死ぬのを防ぐ */
    input:-webkit-autofill{
      -webkit-text-fill-color: var(--text) !important;
      box-shadow: 0 0 0px 1000px rgba(2,6,23,.65) inset !important;
    }

    .cell{ display:flex; flex-direction:column; justify-content:center; }

    .checkCell{
      display:flex;
      justify-content:center;
      align-items:center;
      height: 42px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,253,.18);
      background: rgba(2,6,23,.22);
    }

    .checkCell input{
      width: 16px;
      height: 16px;
      accent-color: #38bdf8;
      cursor:pointer;
    }

    .del{
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,253,.22);
      background: rgba(2,6,23,.25);
      color: var(--muted);
      cursor:pointer;
      display:grid;
      place-items:center;
    }

    .del:hover{
      border-color: rgba(239,68,68,.50);
      background: rgba(127,29,29,.55);
      color: #fecaca;
    }

    .msg{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,253,.18);
      background: rgba(2,6,23,.35);
      font-size: 11px;
      line-height: 1.7;
      color: var(--muted);
    }

    .msg.ok{ border-color: rgba(34,197,94,.35); background: rgba(22,101,52,.25); color: #bbf7d0; }
    .msg.info{ border-color: rgba(96,165,250,.35); background: rgba(30,64,175,.18); color: #dbeafe; }
    .msg.err{ border-color: rgba(239,68,68,.35); background: rgba(127,29,29,.18); color: #fecaca; }
    .msg b{ color: var(--text); font-weight: 750; }

    .tableWrap{
      max-height: 560px;
      overflow:auto;
      border-radius: 16px;
      border: 1px solid rgba(148,163,253,.16);
      background: rgba(2,6,23,.30);
    }

    table{ width:100%; border-collapse: collapse; font-size: 11px; }

    thead th{
      position: sticky;
      top: 0;
      z-index: 2;
      background: rgba(2,6,23,.88);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(148,163,253,.18);
      color: var(--muted);
      font-size: 10px;
      letter-spacing: .06em;
      padding: 10px 8px;
      text-align:center;
      white-space:nowrap;
    }

    tbody td{
      border-bottom: 1px solid rgba(148,163,253,.10);
      padding: 10px 8px;
      text-align:center;
      white-space:nowrap;
    }

    tbody tr:nth-child(2n){ background: rgba(2,6,23,.22); }

    .rules{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,253,.14);
      background: rgba(2,6,23,.28);
      color: var(--muted);
      font-size: 10px;
      line-height: 1.8;
    }
    .rules ul{ margin: 6px 0 0 16px; padding:0; }

    /* =========================================================
       要望：メンバー&条件だけ「完全透過」
       - カード本体 / ヘッダー / 行背景 / 見出し背景などを透明に
       - 入力欄も透明化（枠線のみ）＝本当に透ける
       ========================================================= */
    .card.members{
      background: transparent !important;
      backdrop-filter: none !important;
    }

    .card.members .card-h,
    .card.members .card-b,
    .card.members .row,
    .card.members .listHead,
    .card.members .listTotal,
    .card.members .checkCell,
    .card.members .msg{
      background: transparent !important;
      backdrop-filter: none !important;
    }

    /* メンバー側は枠線だけ残す（不要なら none に） */
    .card.members .row,
    .card.members .listHead{
      border-color: rgba(148,163,253,.18) !important;
    }

    /* 入力欄も透明にして背景を見せる（読みにくければ数値を戻してOK） */
    .card.members input[type="text"],
    .card.members input[type="number"]{
      background: transparent !important;
      border-color: rgba(148,163,253,.30) !important;
      text-shadow: 0 2px 10px rgba(0,0,0,.60);
      box-shadow: 0 0 0 1px rgba(0,0,0,.12) inset;
    }

    .card.members input:-webkit-autofill{
      -webkit-text-fill-color: var(--text) !important;
      box-shadow: 0 0 0px 1000px transparent inset !important;
    }

    .card.members .btn-o{
      background: rgba(0,0,0,.15);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <h1>打撃ローテ自動生成</h1>
        <div class="sub">
          投手・捕手の連続起用と、打撃（マシン＋打者2人）を同時に計算します。<br>
          ローテ本数は「投手のみ」以外（=打撃する人）の人数で自動決定します。<br>
          生成 / 再生成を押すたびに、別解があれば違うローテが出ます。
        </div>
      </div>
      <div class="badge"><span class="dot"></span>ローテ本数（打撃人数）: <b id="statNTop">-</b></div>
    </div>

    <div class="app">
      <!-- 入力 -->
      <div class="card members" id="membersCard">
        <div class="card-h">
          <div class="title"><span class="icon">P</span>メンバー & 条件</div>
          <div class="controls" style="margin:0">
            <button class="btn-o" id="addRowBtn">＋メンバー追加</button>
            <button class="btn-o" id="demoBtn">★デモ読込</button>
            <button class="btn-o" id="clearBtn">クリア</button>
          </div>
        </div>

        <div class="card-b">
          <div class="hint">
            「投手のみ」は打撃に入りません。投手・捕手に入れない人は P連続 / C連続 を 0 にしてください。
          </div>

          <div class="listHead">
            <div class="hcell left">名前</div>
            <div class="hcell">P連続</div>
            <div class="hcell">C連続</div>
            <div class="hcell">投手のみ</div>
            <div></div>
          </div>

          <div class="listTotal">
            <div class="tcell left">ローテ本数: <b id="statN">-</b></div>
            <div class="tcell">合計 <b id="statP">-</b></div>
            <div class="tcell">合計 <b id="statC">-</b></div>
            <div></div><div></div>
          </div>

          <div id="players"></div>

          <div class="controls" style="margin-top:12px">
            <button class="btn" id="generateBtn">▶ 生成 / 再生成</button>
          </div>

          <div id="message"></div>
        </div>
      </div>

      <!-- 出力 -->
      <div class="card">
        <div class="card-h">
          <div class="title"><span class="icon">R</span>ローテ結果</div>
        </div>
        <div class="card-b">
          <div class="tableWrap">
            <table>
              <thead>
                <tr>
                  <th>R</th><th>投手</th><th>捕手</th><th>マシン</th><th>打者1</th><th>打者2</th>
                </tr>
              </thead>
              <tbody id="resultBody"></tbody>
            </table>
          </div>

          <div class="rules">
            <div>ルール</div>
            <ul>
              <li>各列：投手1 / 捕手1 / マシン1 / 打者2（同じ列で同一人物は不可）</li>
              <li>投手・捕手は連続起用（P連続 / C連続）</li>
              <li>打撃は斜め：マシン(r) → 打者1(r+1) → 打者2(r+2)（周回）</li>
              <li>制約：投手・捕手の前後は打撃が入らない（不可能ならその列のみ緩和）</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  window.addEventListener('DOMContentLoaded', () => {
    const playersDiv = document.getElementById('players');
    const msgDiv = document.getElementById('message');
    const tbody = document.getElementById('resultBody');

    const statNTop = document.getElementById('statNTop');
    const statN = document.getElementById('statN');
    const statP = document.getElementById('statP');
    const statC = document.getElementById('statC');

    window.addEventListener('error', (e) => {
      setMessage('err', `JSエラー: ${e.message}`);
    });

    function setMessage(type, html){
      msgDiv.innerHTML = `<div class="msg ${type}">${html}</div>`;
    }
    function clearMessage(){ msgDiv.innerHTML = ''; }

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }
    function uniqCheck(names){ return new Set(names).size === names.length; }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));
    }

    function addPlayerRow(name='', p=0, c=0, pitchOnly=false){
      const row = document.createElement('div');
      row.className = 'row';
      row.innerHTML = `
        <div class="cell">
          <label>名前</label>
          <input type="text" class="name" value="${escapeHtml(name)}">
        </div>
        <div class="cell">
          <label>P連続</label>
          <input type="number" class="pLen" value="${p}" min="0" max="60">
        </div>
        <div class="cell">
          <label>C連続</label>
          <input type="number" class="cLen" value="${c}" min="0" max="60">
        </div>
        <div class="checkCell" title="投手のみ（打撃に入らない）">
          <input type="checkbox" class="pitchOnly" ${pitchOnly ? 'checked':''}>
        </div>
        <button class="del" title="削除">✕</button>
      `;

      const nameEl = row.querySelector('.name');
      const pLenEl = row.querySelector('.pLen');
      const cLenEl = row.querySelector('.cLen');
      const pitchOnlyEl = row.querySelector('.pitchOnly');

      function applyToggles(){
        if (pitchOnlyEl.checked){
          // 「投手のみ」＝捕手はやらない前提（C連続は0固定）
          cLenEl.value = 0;
          cLenEl.disabled = true;
        } else {
          cLenEl.disabled = false;
        }
        updateStats();
      }

      pitchOnlyEl.addEventListener('change', applyToggles);

      row.querySelector('.del').addEventListener('click', () => {
        row.remove();
        updateStats();
      });

      nameEl.addEventListener('input', updateStats);
      pLenEl.addEventListener('input', updateStats);
      cLenEl.addEventListener('input', updateStats);

      playersDiv.appendChild(row);
      applyToggles();
    }

    function loadDemo(){
      playersDiv.innerHTML = '';
      // 初期は全部 0,0 から（順番固定）
      addPlayerRow('森田',   0, 0, false);
      addPlayerRow('林',     0, 0, false);
      addPlayerRow('山田子', 0, 0, false);
      addPlayerRow('祖父江', 0, 0, false);
      addPlayerRow('川瀬',   0, 0, false);
      addPlayerRow('今﨑',   0, 0, false);
      addPlayerRow('浜上',   0, 0, false);
      addPlayerRow('石本',   0, 0, false);
      addPlayerRow('山田泰', 0, 0, false);

      updateStats();
      clearMessage();
      tbody.innerHTML = '';
    }

    function readPlayers(){
      const rows = playersDiv.querySelectorAll('.row');
      const players = [];
      rows.forEach(row => {
        const name = row.querySelector('.name').value.trim();
        if(!name) return;

        const pLen = parseInt(row.querySelector('.pLen').value || '0', 10);
        const cLen = parseInt(row.querySelector('.cLen').value || '0', 10);
        const pitchOnly = row.querySelector('.pitchOnly').checked;

        players.push({name, pLen, cLen, pitchOnly});
      });
      return players;
    }

    // ローテ本数 = 「投手のみ」以外（打撃する人の数）
    function computeN(players){
      return players.filter(p => !p.pitchOnly).length;
    }

    function updateStats(){
      const players = readPlayers();
      const N = computeN(players);

      let totalP = 0, totalC = 0;
      players.forEach(p => { totalP += p.pLen; totalC += p.cLen; });

      statNTop.textContent = String(N);
      statN.textContent = String(N);
      statP.textContent = String(totalP);
      statC.textContent = String(totalC);
    }

    /* ----- solver ----- */

    // 連続ブロックを線形(0..N-1)に配置（重なり禁止）
    function placeBlocksLinear(N, blocks, conflictCheck){
      const arr = new Array(N).fill(null);
      blocks.sort((a,b)=> b.len-a.len || (Math.random()-0.5));

      function dfs(i){
        if(i===blocks.length) return true;
        const {name, len} = blocks[i];

        const starts = [];
        for(let s=0; s<=N-len; s++) starts.push(s);
        shuffle(starts);

        for(const start of starts){
          let ok = true;
          for(let t=start; t<start+len; t++){
            if(arr[t] !== null){ ok=false; break; }
            if(conflictCheck && conflictCheck(name, t)){ ok=false; break; }
          }
          if(!ok) continue;

          for(let t=start; t<start+len; t++) arr[t] = name;
          if(dfs(i+1)) return true;
          for(let t=start; t<start+len; t++) arr[t] = null;
        }
        return false;
      }

      return dfs(0) ? arr : null;
    }

    // 前後制約（投手/捕手の前後に打撃を入れない）の禁止マップ作成
    function buildBanned(N, players, P, C, useMargin){
      const banned = {};
      players.forEach(pl => banned[pl.name] = new Set());

      for(let r=0; r<N; r++){
        const roles = [P[r], C[r]];
        roles.forEach(name => {
          if(!name) return;
          if(useMargin){
            for(let t=r-1; t<=r+1; t++){
              if(t>=0 && t<N) banned[name].add(t);
            }
          } else {
            banned[name].add(r);
          }
        });
      }
      return banned;
    }

    // 打撃人数 N のため、打撃する人は全員 Start を 1回ずつ
    function solveStarts(N, hitters, P, C, banned){
      const remaining = new Map();
      hitters.forEach(p => remaining.set(p.name, 1));

      const Start = new Array(N).fill(null);

      function okToStart(name, r){
        // name が担当する打撃スロット（r, r+1, r+2）に禁止が無いこと
        for(let k=0; k<3; k++){
          const t = (r+k) % N;
          if(banned[name].has(t)) return false;
          if(P[t] === name || C[t] === name) return false;
        }
        return true;
      }

      function dfs(r){
        if(r === N){
          // 周回境界で「同じ人が縦に重なる」のを避ける最低限の整合
          const s0=Start[0], s1=Start[1], sN1=Start[N-1], sN2=Start[N-2];
          if(s0===sN1 || s0===sN2 || s1===sN1 || s1===s0) return false;
          return true;
        }

        const prev1 = (r-1>=0) ? Start[r-1] : null;
        const prev2 = (r-2>=0) ? Start[r-2] : null;

        const cand = [];
        for(const [name, rem] of remaining.entries()){
          if(rem <= 0) continue;
          if(name === prev1 || name === prev2) continue; // 近接重複を避ける
          if(!okToStart(name, r)) continue;
          cand.push(name);
        }
        shuffle(cand);

        for(const name of cand){
          Start[r] = name;
          remaining.set(name, 0);

          if(dfs(r+1)) return true;

          remaining.set(name, 1);
          Start[r] = null;
        }
        return false;
      }

      if(!dfs(0)) return null;

      // Start から実際の列を生成：M[r]=Start[r] / B1[r]=Start[r-1] / B2[r]=Start[r-2]
      const M = new Array(N).fill(null);
      const B1 = new Array(N).fill(null);
      const B2 = new Array(N).fill(null);

      for(let r=0; r<N; r++){
        M[r]  = Start[r];
        B1[r] = Start[(r-1+N)%N];
        B2[r] = Start[(r-2+N)%N];

        // 同一列で重複NG
        if(new Set([P[r], C[r], M[r], B1[r], B2[r]]).size !== 5) return null;
      }
      return {M,B1,B2};
    }

    function solveAll(N, players, useMargin){
      const pBlocks = players.filter(p=> p.pLen>0).map(p=>({name:p.name, len:p.pLen}));
      const cBlocks = players.filter(p=> p.cLen>0).map(p=>({name:p.name, len:p.cLen}));

      const P = placeBlocksLinear(N, pBlocks, null);
      if(!P) return null;

      const C = placeBlocksLinear(N, cBlocks, (name,t)=> P[t]===name);
      if(!C) return null;

      const banned = buildBanned(N, players, P, C, useMargin);

      const hitters = players.filter(p => !p.pitchOnly);
      if(hitters.length !== N) return null;

      const hit = solveStarts(N, hitters, P, C, banned);
      if(!hit) return null;

      return {P, C, ...hit};
    }

    function renderTable(result){
      tbody.innerHTML = '';
      const {P,C,M,B1,B2} = result;
      const N = P.length;
      for(let r=0; r<N; r++){
        const tr = document.createElement('tr');
        [r+1, P[r], C[r], M[r], B1[r], B2[r]].forEach(v => {
          const td = document.createElement('td');
          td.textContent = v || '';
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
    }

    function generateSchedule(){
      clearMessage();
      tbody.innerHTML = '';

      const basePlayers = readPlayers();
      const N = computeN(basePlayers);

      updateStats();

      if(N < 3){
        setMessage('err', `打撃する人（投手のみ以外）が<b>3人以上</b>必要です。`);
        return;
      }

      const names = basePlayers.map(p=>p.name);
      if(!uniqCheck(names)){
        setMessage('err', `同じ名前が複数あります。全員の名前を一意にしてください。`);
        return;
      }

      let totalP=0, totalC=0;
      basePlayers.forEach(p=>{ totalP += p.pLen; totalC += p.cLen; });

      if(totalP !== N || totalC !== N){
        setMessage('err',
          `ローテ本数は<b>${N}</b>（打撃人数）です。<br>` +
          `投手合計=<b>${totalP}</b> / 捕手合計=<b>${totalC}</b> なので、どちらも <b>${N}</b> に揃えてください。`
        );
        return;
      }

      // まず前後制約ありで探索
      let result = solveAll(N, basePlayers, true);
      if(result){
        setMessage('ok', `前後制約あり（投手・捕手の前後は打撃なし）で生成しました。気に入るまで再生成できます。`);
        renderTable(result);
        return;
      }

      // 不可能なら緩和
      result = solveAll(N, basePlayers, false);
      if(result){
        setMessage('info', `前後制約ありでは不可能だったため、その列のみ緩和して生成しました。気に入るまで再生成できます。`);
        renderTable(result);
        return;
      }

      setMessage('err', `条件を満たすローテが見つかりませんでした。P/Cの連続数や合計を調整してください。`);
    }

    // buttons
    document.getElementById('addRowBtn').addEventListener('click', () => {
      addPlayerRow('',0,0,false);
      updateStats();
    });

    document.getElementById('demoBtn').addEventListener('click', loadDemo);

    document.getElementById('clearBtn').addEventListener('click', () => {
      playersDiv.innerHTML = '';
      tbody.innerHTML = '';
      clearMessage();
      updateStats();
    });

    document.getElementById('generateBtn').addEventListener('click', generateSchedule);

    // init
    loadDemo();
  });
})();
</script>
</body>
</html>
